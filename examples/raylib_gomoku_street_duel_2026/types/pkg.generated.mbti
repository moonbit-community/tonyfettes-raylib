// Generated using `moon info`, DON'T EDIT IT
package "tonyfettes/raylib-examples/raylib_gomoku_street_duel_2026/types"

// Values
pub fn absf(Float) -> Float

pub fn board_index(Int, Int) -> Int

pub fn board_metrics(Game) -> (Int, Int, Int)

pub let board_n : Int

pub fn burst_move(Game, Int, Int, Int, SparkKind) -> Unit

pub fn cell_at(Game, Int, Int) -> Player

pub fn clampi(Int, Int, Int) -> Int

pub fn clear_button_rect() -> (Int, Int, Int, Int)

pub fn clear_hint(Game) -> Unit

pub fn dpad_center_x() -> Int

pub fn dpad_center_y() -> Int

pub fn dpad_size() -> Int

pub fn hint_button_rect() -> (Int, Int, Int, Int)

pub fn in_board(Int, Int) -> Bool

pub fn inside_rect(Float, Float, Int, Int, Int, Int) -> Bool

pub let max_cells : Int

pub fn maxf(Float, Float) -> Float

pub fn maxi(Int, Int) -> Int

pub fn mini(Int, Int) -> Int

pub fn next_button_rect() -> (Int, Int, Int, Int)

pub fn panel_x() -> Int

pub fn place_button_rect() -> (Int, Int, Int, Int)

pub fn pointer_on_rect(Float, Float, Bool, Int, Int, Int, Int, Int) -> Bool

pub fn randf(Float, Float) -> Float

pub fn reset_button_rect() -> (Int, Int, Int, Int)

pub let screen_h : Int

pub let screen_w : Int

pub fn set_cell(Game, Int, Int, Player) -> Unit

pub fn set_message(Game, String, Float) -> Unit

pub fn spawn_spark(Game, Float, Float, Float, Float, Float, Float, SparkKind) -> Unit

pub fn start_button_rect() -> (Int, Int, Int, Int)

pub let target_fps : Int

pub fn undo_button_rect() -> (Int, Int, Int, Int)

pub fn world_center(Game, Int, Int) -> (Float, Float, Float)

// Errors

// Types and methods
pub(all) enum Dir {
  DirNone
  Left
  Right
  Up
  Down
}
pub impl Eq for Dir

pub(all) struct Game {
  board : Array[Player]
  hist_x : Array[Int]
  hist_y : Array[Int]
  hist_p : Array[Player]
  mut hist_len : Int
  sparks : Array[Spark]
  mut state : GameState
  mut turn : Player
  mut winner : Player
  mut move_count : Int
  mut human_wins : Int
  mut ai_wins : Int
  mut draws : Int
  mut cursor_x : Int
  mut cursor_y : Int
  mut last_hx : Int
  mut last_hy : Int
  mut last_ax : Int
  mut last_ay : Int
  mut hints_left : Int
  mut hint_active : Bool
  mut hint_x : Int
  mut hint_y : Int
  mut hint_ttl : Float
  mut ai_delay : Float
  mut game_time : Float
  mut hold_dir : Dir
  mut repeat_t : Float
  mut touch_action_cd : Float
  mut message : String
  mut message_t : Float
  mut shake_t : Float
  mut ui_t : Float
  mut mouse_x : Float
  mut mouse_y : Float
  mut mouse_hold : Bool
  mut mouse_press : Bool
  mut touch_count : Int
}
pub fn Game::new() -> Self

pub(all) enum GameState {
  Title
  Play
  Result
}
pub impl Eq for GameState

pub(all) enum Player {
  Empty
  Human
  AI
}
pub impl Eq for Player

pub(all) struct Spark {
  mut active : Bool
  mut x : Float
  mut y : Float
  mut vx : Float
  mut vy : Float
  mut life : Float
  mut size : Float
  mut kind : SparkKind
}

pub(all) enum SparkKind {
  SparkAI
  SparkHuman
  SparkUndo
  SparkHint
}
pub impl Eq for SparkKind

// Type aliases

// Traits

